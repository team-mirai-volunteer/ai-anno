using NUnit.Framework;
using System;
using System.Collections;
using System.Threading;
using UnityEngine;
using UnityEngine.TestTools;
using AiTuber.Services.Legacy.Dify;
using AiTuber.Services.Legacy.Dify.Audio;
using AiTuber.Services.Legacy.Dify.Data;
using AiTuber.Tests.Dify;

namespace AiTuber.Editor.Tests
{
    /// <summary>
    /// DifyServiceのIDifyEventService実装の統合テスト
    /// 実際の動作確認：eventType別イベント配信の検証
    /// </summary>
    [TestFixture]
    public class DifyServiceEventSystemTests
    {
        private DifyServiceConfig _config;
        private DifyService _difyService;
        private MockDifyApiClient _mockApiClient;
        
        // イベント受信フラグ
        private bool _audioEventReceived;
        private bool _textEventReceived;
        private bool _workflowEventReceived;
        private DifyStreamEvent _receivedAudioEvent;
        private DifyStreamEvent _receivedTextEvent;
        private DifyStreamEvent _receivedWorkflowEvent;
        
        [SetUp]
        public void Setup()
        {
            _config = new DifyServiceConfig
            {
                ApiKey = "test-api-key-12345678",
                ApiUrl = "https://test-api.com",
                EnableDebugLogging = true,
                EnableAudioProcessing = true
            };
            
            _mockApiClient = new MockDifyApiClient
            {
                ApiKey = _config.ApiKey,
                ApiUrl = _config.ApiUrl,
                ShouldThrowException = false,
                ShouldReturnError = false
            };
            // テスト用音声データを設定
            _mockApiClient._mockAudioData = new byte[] { 1, 2, 3, 4, 5 };
            
            _difyService = new DifyService(_mockApiClient, _config);
            
            // イベント受信状態リセット
            _audioEventReceived = false;
            _textEventReceived = false;
            _workflowEventReceived = false;
            _receivedAudioEvent = null;
            _receivedTextEvent = null;
            _receivedWorkflowEvent = null;
        }
        
        [TearDown]
        public void TearDown()
        {
            _difyService = null;
            _mockApiClient = null;
        }
        
        [Test]
        public void DifyService_IDifyEventServiceインターフェース実装_正しく継承されている()
        {
            // Assert
            Assert.IsTrue(_difyService is IDifyEventService, "DifyServiceがIDifyEventServiceを実装していること");
            Assert.IsNotNull(_difyService as IDifyEventService, "IDifyEventServiceとしてキャスト可能であること");
            
            // イベントがnullでないことを確認
            IDifyEventService eventService = _difyService;
            Assert.IsNotNull(eventService, "IDifyEventServiceとしてアクセス可能であること");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_成功レスポンス_OnAudioMessageイベント発火()
        {
            // Arrange
            _difyService.OnAudioMessage += (audioEvent) =>
            {
                _audioEventReceived = true;
                _receivedAudioEvent = audioEvent;
                Debug.Log($"[TEST] Audio event received: {audioEvent.@event}, Audio length: {audioEvent.audio?.Length ?? 0}");
            };
            
            // Act
            var task = _difyService.ProcessUserQueryAsync("test audio query", "user-123", conversationId: null, onStreamEvent: null, CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsTrue(result.IsSuccess, "処理が成功すること");
            Assert.IsTrue(_audioEventReceived, "OnAudioMessageイベントが発火されること");
            Assert.IsNotNull(_receivedAudioEvent, "音声イベントデータが正しく渡されること");
            Assert.AreEqual("tts_message", _receivedAudioEvent.@event, "イベントタイプがtts_messageであること");
            Assert.IsNotNull(_receivedAudioEvent.audio, "音声データが含まれること");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_成功レスポンス_OnTextMessageイベント発火()
        {
            // Arrange
            _difyService.OnTextMessage += (textEvent) =>
            {
                _textEventReceived = true;
                _receivedTextEvent = textEvent;
                Debug.Log($"[TEST] Text event received: {textEvent.@event}, Answer: {textEvent.answer}");
            };
            
            // Act
            var task = _difyService.ProcessUserQueryAsync("test text query", "user-456", conversationId: null, onStreamEvent: null, CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsTrue(result.IsSuccess, "処理が成功すること");
            Assert.IsTrue(_textEventReceived, "OnTextMessageイベントが発火されること");
            Assert.IsNotNull(_receivedTextEvent, "テキストイベントデータが正しく渡されること");
            Assert.AreEqual("message", _receivedTextEvent.@event, "イベントタイプがmessageであること");
            Assert.IsNotNull(_receivedTextEvent.answer, "テキスト内容が含まれること");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_複数イベント受信_全イベントタイプ正しく配信()
        {
            // Arrange
            int audioCount = 0, textCount = 0, workflowCount = 0;
            
            _difyService.OnAudioMessage += (audioEvent) => 
            {
                audioCount++;
                Debug.Log($"[TEST] Audio event #{audioCount}: {audioEvent.@event}");
            };
            _difyService.OnTextMessage += (textEvent) => 
            {
                textCount++;
                Debug.Log($"[TEST] Text event #{textCount}: {textEvent.@event}");
            };
            _difyService.OnWorkflowFinished += (workflowEvent) => 
            {
                workflowCount++;
                Debug.Log($"[TEST] Workflow event #{workflowCount}: {workflowEvent.@event}");
            };
            
            // Act
            var task = _difyService.ProcessUserQueryAsync("test multi events query", "user-789", conversationId: null, onStreamEvent: null, CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsTrue(result.IsSuccess, "処理が成功すること");
            
            // 既存のMockDifyApiClientは固定的なイベントパターンを返すため
            // 実際に返されるイベント数に応じて検証
            Debug.Log($"[TEST] Event counts - Audio: {audioCount}, Text: {textCount}, Workflow: {workflowCount}");
            
            // 少なくとも何らかのイベントが発火されていることを確認
            Assert.IsTrue(audioCount > 0 || textCount > 0 || workflowCount > 0, "何らかのイベントが発火されること");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_APIエラー時_イベント発火されない()
        {
            // Arrange
            _mockApiClient.ShouldReturnError = true;
            
            _difyService.OnAudioMessage += (audioEvent) => _audioEventReceived = true;
            _difyService.OnTextMessage += (textEvent) => _textEventReceived = true;
            _difyService.OnWorkflowFinished += (workflowEvent) => _workflowEventReceived = true;
            
            // Act
            var task = _difyService.ProcessUserQueryAsync("test error query", "user-error", conversationId: null, onStreamEvent: null, CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsFalse(result.IsSuccess, "エラー時は処理が失敗すること");
            Assert.IsFalse(_audioEventReceived, "エラー時はOnAudioMessageイベントが発火されないこと");
            Assert.IsFalse(_textEventReceived, "エラー時はOnTextMessageイベントが発火されないこと");
            Assert.IsFalse(_workflowEventReceived, "エラー時はOnWorkflowFinishedイベントが発火されないこと");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_API例外時_イベント発火されない()
        {
            // Arrange
            _mockApiClient.ShouldThrowException = true;
            
            _difyService.OnAudioMessage += (audioEvent) => _audioEventReceived = true;
            _difyService.OnTextMessage += (textEvent) => _textEventReceived = true;
            _difyService.OnWorkflowFinished += (workflowEvent) => _workflowEventReceived = true;
            
            // 期待されるエラーログを設定
            LogAssert.Expect(LogType.Error, new System.Text.RegularExpressions.Regex(".*ProcessUserQueryAsync failed.*"));
            
            // Act
            var task = _difyService.ProcessUserQueryAsync("test exception query", "user-exception", conversationId: null, onStreamEvent: null, CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsFalse(result.IsSuccess, "例外時は処理が失敗すること");
            Assert.IsFalse(_audioEventReceived, "例外時はOnAudioMessageイベントが発火されないこと");
            Assert.IsFalse(_textEventReceived, "例外時はOnTextMessageイベントが発火されないこと");
            Assert.IsFalse(_workflowEventReceived, "例外時はOnWorkflowFinishedイベントが発火されないこと");
        }
        
        [UnityTest]
        public IEnumerator ProcessUserQueryAsync_既存コールバックと併用_両方正しく動作()
        {
            // Arrange
            bool callbackReceived = false;
            DifyStreamEvent callbackEvent = null;
            
            _difyService.OnTextMessage += (textEvent) =>
            {
                _textEventReceived = true;
                _receivedTextEvent = textEvent;
            };
            
            // Act
            var task = _difyService.ProcessUserQueryAsync(
                "test callback query", 
                "user-callback", 
                conversationId: null,
                onStreamEvent: (evt) => 
                {
                    callbackReceived = true;
                    callbackEvent = evt;
                    Debug.Log($"[TEST] Callback received: {evt.@event}");
                },
                CancellationToken.None);
            
            // Wait for completion
            while (!task.IsCompleted)
            {
                yield return null;
            }
            
            var result = task.Result;
            
            // Assert
            Assert.IsTrue(result.IsSuccess, "処理が成功すること");
            Assert.IsTrue(callbackReceived, "既存コールバックが動作すること");
            Assert.IsNotNull(callbackEvent, "コールバックでイベントデータが渡されること");
            
            // イベントシステムも並行して動作することを確認
            // （受信されるイベントタイプに依存するため、柔軟に検証）
            if (_textEventReceived)
            {
                Assert.IsNotNull(_receivedTextEvent, "新しいイベントシステムも動作すること");
                Debug.Log($"[TEST] Both systems worked: Callback={callbackEvent.@event}, Event={_receivedTextEvent.@event}");
            }
        }
    }
}